---
jupytext:
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: archimedes
---

# Textbook model


```{code-cell} python
:tags: [hide-cell]
import numpy as np
import archimedes as arc

from engine import Tidl_interpolant, Tmil_interpolant, Tmax_interpolant
from aero import (
    cx_interpolant,
    cz_interpolant,
    cl_interpolant,
    cm_interpolant,
    cn_interpolant,
    dlda,
    dldr,
    dnda,
    dndr,
    calc_damping,
)
```


```{code-cell} python
:tags: [hide-cell]
def adc(Vt, alt):
    """Standard atmosphere model"""
    R0 = 2.377e-3  # Density scale [slug/ft^3]
    gamma = 1.4  # Adiabatic index for air [-]
    Rs = 1716.3  # Specific gas constant for air [ft·lbf/slug-R]
    Tfac = 1 - 0.703e-5 * alt  # Temperature factor

    T = np.where(alt >= 35000.0, 390.0, 519.0 * Tfac)

    if alt > 35000.0:
        T = 390.0
    else:
        T = 519.0 * Tfac

    rho = R0 * Tfac**4.14
    amach = Vt / np.sqrt(gamma * Rs * T)
    qbar = 0.5 * rho * Vt**2

    return amach, qbar


def tgear(thtl):
    "tgear function"

    if thtl <= 0.77:
        tg = 64.94 * thtl
    else:
        tg = 217.38 * thtl - 117.38

    return tg


def rtau(dp):
    "rtau function"

    if dp <= 25:
        rt = 1.0
    elif dp >= 50:
        rt = 0.1
    else:
        rt = 1.9 - 0.036 * dp

    return rt


def pdot(p3, p1):
    "pdot function"

    if p1 >= 50:
        if p3 >= 50:
            t = 5
            p2 = p1
        else:
            p2 = 60
            t = rtau(p2 - p3)
    else:
        if p3 >= 50:
            t = 5
            p2 = 40
        else:
            p2 = p1
            t = rtau(p2 - p3)

    pd = t * (p2 - p3)

    return pd


def thrust(pow, alt, rmach):
    T_mil = Tmil_interpolant(alt, rmach)
    T_idl = Tidl_interpolant(alt, rmach)
    T_max = Tmax_interpolant(alt, rmach)

    return np.where(
        pow < 50.0,
        T_idl + (T_mil - T_idl) * pow * 0.02,
        T_mil + (T_max - T_mil) * (pow - 50.0) * 0.02,
    )


def cx(alpha, el):
    return cx_interpolant(alpha, el)


def cy(beta, ail, rdr):
    return -0.02 * beta + 0.021 * (ail / 20) + 0.086 * (rdr / 30)


def cz(alpha, beta, el):
    cz_lookup = cz_interpolant(alpha)
    return (-0.19 / 25) * el + cz_lookup * (1.0 - (beta / 57.3) ** 2)


def cl(alpha, beta):
    return np.sign(beta) * cl_interpolant(alpha, np.abs(beta))


def cm(alpha, el):
    return cm_interpolant(alpha, el)


def cn(alpha, beta):
    return np.sign(beta) * cn_interpolant(alpha, np.abs(beta))


def f16_dynamics(x, controls, xcg=0.35, weight=20490.4459):
    thtl, el, ail, rdr = controls
    xd = np.zeros_like(x)

    Axx = 9496.0
    Ayy = 55814.0
    Azz = 63100.0
    Axz = 982.0
    Axzs = Axz**2
    xpq = Axz * (Axx - Ayy + Azz)
    gam = Axx * Azz - Axz**2
    xqr = Azz * (Azz - Ayy) + Axzs
    zpq = (Axx - Ayy) * Axx + Axzs
    ypr = Azz - Axx
    gd = 32.17
    mass = weight / gd

    s = 300.0
    b = 30.0
    cbar = 11.32
    xcgr = 0.35  # Reference CG location
    hx = 160.0
    rtod = 57.29578

    # Assign state & control variables
    vt = x[0]
    alpha = x[1]
    beta = x[2]

    cbta = np.cos(beta)
    u = vt * np.cos(alpha) * cbta
    v = vt * np.sin(beta)
    w = vt * np.sin(alpha) * cbta

    alpha_deg = alpha * rtod
    beta_deg = beta * rtod
    phi = x[3]
    theta = x[4]
    psi = x[5]
    p = x[6]
    q = x[7]
    r = x[8]
    alt = x[11]
    pow = x[12]

    # Air data computer and engine model
    amach, qbar = adc(vt, alt)
    cpow = tgear(thtl)
    xd[12] = pdot(pow, cpow)
    t = thrust(pow, alt, amach)

    # Lookup tables and component buildup
    cxt = cx(alpha_deg, el)
    cyt = cy(beta_deg, ail, rdr)
    czt = cz(alpha_deg, beta_deg, el)
    dail = ail / 20.0
    drdr = rdr / 30.0
    clt = (
        cl(alpha_deg, beta_deg)
        + dlda(alpha_deg, beta_deg) * dail
        + dldr(alpha_deg, beta_deg) * drdr
    )
    cmt = cm(alpha_deg, el)
    cnt = (
        cn(alpha_deg, beta_deg)
        + dnda(alpha_deg, beta_deg) * dail
        + dndr(alpha_deg, beta_deg) * drdr
    )

    # Add damping derivatives
    tvt = 0.5 / vt
    b2v = b * tvt
    cq = cbar * q * tvt
    d = calc_damping(alpha_deg)
    cxt = cxt + cq * d[0]
    cyt = cyt + b2v * (d[1] * r + d[2] * p)
    czt = czt + cq * d[3]

    clt = clt + b2v * (d[4] * r + d[5] * p)
    cmt = cmt + cq * d[6] + czt * (xcgr - xcg)
    cnt = cnt + b2v * (d[7] * r + d[8] * p) - cyt * (xcgr - xcg) * cbar / b

    # Prep for state equations
    sth = np.sin(theta)
    cth = np.cos(theta)
    sph = np.sin(phi)
    cph = np.cos(phi)
    spsi = np.sin(psi)
    cpsi = np.cos(psi)
    qs = qbar * s
    qsb = qs * b
    rmqs = qs / mass
    gcth = gd * cth
    qsph = q * sph
    ay = rmqs * cyt
    az = rmqs * czt

    # Force equations
    udot = r * v - q * w - gd * sth + (qs * cxt + t) / mass
    vdot = p * w - r * u + gcth * sph + ay
    wdot = q * u - p * v + gcth * cph + az

    dum = u * u + w * w
    xd[0] = (u * udot + v * vdot + w * wdot) / vt
    xd[1] = (u * wdot - w * udot) / dum
    xd[2] = (vt * vdot - v * xd[0]) * cbta / dum

    # kinematics
    xd[3] = p + (sth / cth) * (qsph + r * cph)
    xd[4] = q * cph - r * sph
    xd[5] = (qsph + r * cph) / cth

    # Moments
    roll = qsb * clt
    pitch = qs * cbar * cmt
    yaw = qsb * cnt
    pq = p * q
    qr = q * r
    qhx = q * hx
    xd[6] = (xpq * pq - xqr * qr + Azz * roll + Axz * (yaw + qhx)) / gam
    xd[7] = (ypr * p * r - Axz * (p**2 - r**2) + pitch - r * hx) / Ayy
    xd[8] = (zpq * pq - xpq * qr + Axz * roll + Axx * (yaw + qhx)) / gam

    # navigation
    t1 = sph * cpsi
    t2 = cph * sth
    t3 = sph * spsi
    s1 = cth * cpsi
    s2 = cth * spsi
    s3 = t1 * sth - cph * spsi
    s4 = t3 * sth + cph * cpsi
    s5 = sph * cth
    s6 = t2 * cpsi + t3
    s7 = t2 * spsi - t1
    s8 = cph * cth
    xd[9] = u * s1 + v * s3 + w * s6  # north speed
    xd[10] = u * s2 + v * s4 + w * s7  # east speed
    xd[11] = u * sth - v * s5 - w * s8  # vertical speed

    return xd
```



<!-- Unit tests -->
```{code-cell} python
:tags: [hide-cell]

# From Stevens, Lewis, Johnson Table 3.5-2
def test_352():
    u = np.array([0.9, 20.0, -15.0, -20.0])
    x = np.array(
        [
            500.0,
            0.5,
            -0.2,
            -1.0,
            1.0,
            -1.0,
            0.7,
            -0.8,
            0.9,
            1000.0,
            900.0,
            10000.0,
            90.0,
        ]
    )

    # NOTE: There is a typo in the chapter 3 code implementation of the DCM,
    # leading to a sign change for yaw rate xd[11].  Hence, Table 3.5-2 has
    # 248.1241 instead of -248.1241 (the latter is consistent with the SciPy
    # DCM implementation).
    xd_expected = np.array(
        [
            -75.23724,
            -0.8813491,
            -0.4759990,
            2.505734,
            0.3250820,
            2.145926,
            12.62679,
            0.9649671,
            0.5809759,
            342.4439,
            -266.7707,
            248.1241,
            -58.68999,
        ]
    )

    xd = f16_dynamics(x, u, xcg=0.4)

    assert np.allclose(xd, xd_expected, atol=1e-2)
    print(f"Test 3.5.2:")
    print(f"  Trimmed:\t\t✓")


# From Stevens, Lewis, Johnson Table 3.6-2
def test_362():
    vt = 5.020000e2
    alpha = 2.392628e-1
    beta = 5.061803e-4

    thtl = 8.349601e-1
    el = -1.481766e0
    ail = 9.553108e-2
    rdr = -4.118124e-1

    x = np.array(
        [
            vt,
            alpha,
            beta,
            1.366289e0,
            5.000808e-2,
            2.340769e-1,
            -1.499617e-2,
            2.933811e-1,
            6.084932e-2,
            0.0,
            0.0,
            0.0,
            6.412363e1,
        ]
    )

    u = np.array([thtl, el, ail, rdr])

    xd = f16_dynamics(x, u, xcg=0.35)
    zero_idx = [0, 1, 2, 6, 7, 8]
    print(f"\nTest 3.6")
    assert np.allclose(xd[zero_idx], 0.0, atol=1e-4)
    print(f"  Trimmed:\t\t✓")
    assert np.allclose(xd[3], 0.0, atol=1e-4)
    print(f"  Roll rate:\t\t✓")
    assert np.allclose(xd[4], 0.0, atol=1e-4)
    print(f"  Pitch rate:\t\t✓")
    assert np.allclose(xd[5], 0.3, atol=1e-4)
    print(f"  Turn rate:\t\t✓")

    # Turn coordination when flight path angle is zero
    phi = x[3]
    gd = 32.17
    G = xd[5] * vt / gd
    tph1 = np.tan(phi)
    tph2 = G * np.cos(beta) / (np.cos(alpha) - G * np.sin(alpha) * np.sin(beta))
    assert np.allclose(tph1, tph2, atol=1e-4)
    print(f"  Turn coord:\t\t✓")


# Trim conditions (3.6-3)
def test_363():
    vt = 5.020000e2
    alpha = 0.03691
    beta = -4e-9

    thtl = 0.1385  # Throttle setting [0-1]
    el = -0.7588  # Elevator angle [deg]
    ail = -1.2e-7  # Aileron angle [deg]
    rdr = -6.2e-7  # Rudder angle [deg]

    x = np.array(
        [
            vt,
            alpha,
            beta,
            0.0,
            0.03691,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            0.0,
            tgear(thtl),
        ]
    )

    u = np.array([thtl, el, ail, rdr])

    xd = f16_dynamics(x, u, xcg=0.35)
    zero_idx = [0, 1, 2, 6, 7, 8]

    print("\nTest 3.6-3:")
    assert np.allclose(xd[zero_idx], 0.0, atol=1e-3)
    print(f"  Trimmed:\t\t✓")

test_352()
test_362()
test_363()
```