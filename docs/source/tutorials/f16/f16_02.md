# Building the Model

After [Part 1](f16_01.md), we now have a validated implementation of the Stevens-Lewis-Johnson F-16 model that's compatible with Archimedes for ODE solving, autodiff, trajectory optimization etc.

However, we've also seen some of the disadvantages of the "monolithic" implementation, namely:

1. It doesn't clearly delineate distinct physics (gravity vs aerodynamics, for instance)
2. The monolithic code is difficult to test, debug, and validate against subsystem test data
3. We can't take advantage of reusable components like rigid body dynamics, gravity, and atmosphere models.
4. It's difficult to replace subsystem models without modifying the main dynamics model
5. As the model grows in complexity, the flat state and input vectors become more difficult to manually manipulate

We could largely address 1-3 through classic "single responsibility" scoping, breaking the monolithic dynamics model into a series of smaller functions responsible for computing gravity, engine thrust, aerodynamic coefficients, etc.

However, this doesn't address the problem of abstracting subsystem models and working with large flat vectors.
For example, suppose we wanted to see whether we could replace NASA's single-lag engine model with a lookup table.
How much does this change the actual results?

Even if we broke the dynamics function into modular, reusable subsystem functions, we'd still need to modify the main code everywhere the state vector appears - and then remember to change it back if we decide to revert to the NASA model.
This problem compounds with complex systems, and makes it difficult to reliably alter the architecture of your physics model without the cognitive load of manually indexing state and control vectors.

Instead, we'll take a hierarchical approach, defining the flight dynamics model with nested subsystems - something like a Python version of Reference and Variant Subsystems in Simulink.
For much more on the "why" and "how" of this, see the tutorials on [Structured Data Types](../../trees.md) and [Hierarchical Modeling](../hierarchical/hierarchical00.md).
This structure can be reused for many conventional fixed-wing aircraft, and with light modifications can be adapted to a wide variety of other vehicle dynamics models as well.

## Identifying Subsystems

So, what's in an F-16 model?

We'll consider a number of "subsystems":

- Aerodynamics
- Engine
- Control surface actuators
- Gravity
- Atmosphere
- Rigid body dynamics

Following the hierarchical dynamics modeling design pattern, we will first create an abstract base class or `Protocol` for each of these that clearly defines the inputs and outputs.
Then we can add dynamic state to each concrete implementation as necessary.

- Need F-16 component graphic from slide deck
- Break down the different physics
- Define interfaces
- Point to GitHub for full implementation

